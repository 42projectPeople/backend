# This workflow will build and push a new container image to Amazon ECR,
# and then will deploy a new task definition to Amazon ECS, when there is a push to the "main" branch.
#
# To use this workflow, you will need to complete the following set-up steps:
#
# 1. Create an ECR repository to store your images.
#    For example: `aws ecr create-repository --repository-name my-ecr-repo --region us-east-2`.
#    Replace the value of the `ECR_REPOSITORY` environment variable in the workflow below with your repository's name.
#    Replace the value of the `AWS_REGION` environment variable in the workflow below with your repository's region.
#
# 2. Create an ECS task definition, an ECS cluster, and an ECS service.
#    For example, follow the Getting Started guide on the ECS console:
#      https://us-east-2.console.aws.amazon.com/ecs/home?region=us-east-2#/firstRun
#    Replace the value of the `ECS_SERVICE` environment variable in the workflow below with the name you set for the Amazon ECS service.
#    Replace the value of the `ECS_CLUSTER` environment variable in the workflow below with the name you set for the cluster.
#
# 3. Store your ECS task definition as a JSON file in your repository.
#    The format should follow the output of `aws ecs register-task-definition --generate-cli-skeleton`.
#    Replace the value of the `ECS_TASK_DEFINITION` environment variable in the workflow below with the path to the JSON file.
#    Replace the value of the `CONTAINER_NAME` environment variable in the workflow below with the name of the container
#    in the `containerDefinitions` section of the task definition.
#
# 4. Store an IAM user access key in GitHub Actions secrets named `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`.
#    See the documentation for each action used below for the recommended IAM policies for this IAM user,
#    and best practices on handling the access key credentials.

name: Deploy to Amazon ECS

on:
  pull_request:
    branches:
    - release_test

env:
  AWS_REGION: ap-northeast-2                   # set this to your preferred AWS region, e.g. us-west-1

jobs:
  deploy:
    name: Deploy Develop
    runs-on: ubuntu-latest
    outputs:
      deploymentId: ${{ steps.create-deployment.outputs.deploymendId }}
    environment: production

    steps:
    - name: Install Secret
      run: |
        echo "pwd:: $PWD"
        echo "HOST=$DEV_DB_HOST"  >> .env.dev
        echo "DATABASE=$DEV_DB_DATABASE" >> .env.dev
        echo "PASSWORD=$DEV_DB_PASSWORD" >> .env.dev
        echo "PORT=$DEV_DB_PORT" >> .env.dev
        echo "DBUSER=$DEV_DB_USER" >> .env.dev
        echo "JWT_SECRET=$DEV_JWT_SECRET" >> .env.dev
        echo "JWT_ACCESS_EXPIRE=$DEV_JWT_ACCESS_EXPIRE" >> .env.dev
        echo "JWT_REFRESH_EXPIRE=$DEV_JWT_REFRESH_EXPIRE" >> .env.dev
        echo "EXP_ROTATION_THRESHOLD=$DEV_EXP_ROTATION_THRESHOLD" >> .env.dev
        echo "GOOGLE_CLIENT_ID=$DEV_GOOGLE_CLIENT_ID" >> .env.dev
        echo "GOOGLE_CLIENT_SECRET=$DEV_GOOGLE_CLIENT_SECRET" >> .env.dev
        echo "GOOGLE_CALLBACK_URL=$DEV_GOOGLE_CALLBACK_URL" >> .env.dev
        echo "NAVER_CLOUD_MAP_CLIENT_KEY=$DEV_NAVER_CLOUD_MAP_CLIENT_KEY" >> .env.dev
        echo "NAVER_CLOUD_MAP_SECRET_KEY=$DEV_NAVER_CLOUD_MAP_SECRET_KEY" >> .env.dev
        echo "NAVER_CLOUD_SEARCH_CLIENT_KEY=$DEV_NAVER_CLOUD_SEARCH_CLIENT_KEY" >> .env.dev
        echo "NAVER_CLOUD_SEARCH_SECRET_KEY=$DEV_NAVER_CLOUD_SEARCH_SECRET_KEY" >> .env.dev
      env:
        DEV_DB_HOST:							${{ secrets.DEV_DB_HOST }}
        DEV_DB_DATABASE:						${{ secrets.DEV_DB_DATABASE }}
        DEV_DB_PASSWORD:						${{ secrets.DEV_DB_PASSWORD }}
        DEV_DB_PORT:							${{ secrets.DEV_DB_PORT }}
        DEV_DB_USER:							${{ secrets.DEV_DB_USER }}
        DEV_JWT_SECRET:							${{ secrets.DEV_JWT_SECRET }}
        DEV_JWT_ACCESS_EXPIRE:					${{ secrets.DEV_JWT_ACCESS_EXPIRE }}
        DEV_JWT_REFRESH_EXPIRE:					${{ secrets.DEV_JWT_REFRESH_EXPIRE }}
        DEV_EXP_ROTATION_THRESHOLD:				${{ secrets.DEV_EXP_ROTATION_THRESHOLD }}
        DEV_GOOGLE_CLIENT_ID:					${{ secrets.DEV_GOOGLE_CLIENT_ID }}
        DEV_GOOGLE_CLIENT_SECRET:				${{ secrets.DEV_GOOGLE_CLIENT_SECRET }}
        DEV_GOOGLE_CALLBACK_URL:				${{ secrets.DEV_GOOGLE_CALLBACK_URL }}
        DEV_NAVER_CLOUD_MAP_CLIENT_KEY:			${{ secrets.DEV_NAVER_CLOUD_MAP_CLIENT_KEY }}
        DEV_NAVER_CLOUD_MAP_SECRET_KEY:			${{ secrets.DEV_NAVER_CLOUD_MAP_SECRET_KEY  }}
        DEV_NAVER_CLOUD_SEARCH_CLIENT_KEY:		${{ secrets.DEV_NAVER_CLOUD_SEARCH_CLIENT_KEY }}
        DEV_NAVER_CLOUD_SEARCH_SECRET_KEY:		${{ secrets.DEV_NAVER_CLOUD_SEARCH_SECRET_KEY }}

        
    - name: Checkout
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: S3 업로드
      run: aws deploy push --application-name test_release --description "upload test server file in s3" --s3-location s3://moim-test-release/moim.zip --source .

    - name: Create CodeDeploy Deployment
      id: create-deployment
      run: aws deploy create-deployment --application-name test_release  --deployment-config-name CodeDeployDefault.OneAtATime --deployment-group-name test_group --s3-location bucket=moim-test-release,bundleType=zip,key=moim.zip >> $GITHUB_OUTPUT

    - name: Wait for deployment to finish
      run: |
        echo ${{ steps.create-deployment.outputs.deploymentId }}
        aws deploy wait deployment-successful --deployment-id ${{ steps.create-deployment.outputs.deploymentId }}
